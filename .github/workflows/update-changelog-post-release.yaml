name: Create Changelog PR after release

on:
  release:
    types: [published]
jobs:
  createIssue:
    runs-on: ubuntu-latest

    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Create Changelog PR 
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const owner = "defenseunicorns";
            const repo = "go-oscal";
            const defaultRef = "heads/main";
            const filePath = "CHANGELOG.md";
            const unreleasedTitle = '## [unreleased] - yyyy-mm-dd';
            const unreleasedUrlPrefix = `[unreleased]:`
            const version = context.payload.release.tag_name;

            // Get the formatted release date
            const published_at = context.payload.release.published_at;
            const date = published_at.split("T")[0];
            
            // Create the release title
            const releaseTitle = `## [${version}] - ${date}`;

            // Create the issue title and body
            const issueTitle = `update changelog for ${repo} ${version}`;
            const issueBody = `A new release of ${repo} has been published. Please review changes to the CHANGELOG.md and update accordingly.`;
            
            // search for an existing issue or create a new one if it doesn't exist
            const {
              data: { items: issues }
            } = await github.rest.search.issuesAndPullRequests({
              q: `${issueTitle} repo:${owner}/${repo} is:issue is:open in:title`
            });
        
            // set the issue to the first issue found if it exists
            // otherwise, create the issue
            let issue;
            if (issues.length > 0) {
              issue = issues[0];
            } else {
              const res = await github.rest.issues.create({
                owner: owner,
                repo: repo,
                title: issueTitle,
                body: issueBody,
                labels: ['documentation']
              });
              issue = res.data;
            }
        
            // create a branch title
            const branchTitle = `${issue.number}-update-changelog-${version}`;
        
            // create a branch ref
            const branchRef = `refs/heads/${branchTitle}`
        
            // get the default branch sha
            const { data: { object: { sha: defaultSha } } } = await github.rest.git.getRef({
              owner,
              repo,
              ref: defaultRef
            });
        
            // try to create a new branch
            try {
              await github.rest.git.createRef({
                owner,
                repo,
                ref: branchRef,
                sha: defaultSha
              });
            } catch (error) {
              // throw error if not branch already exists
              if (error.status !== 422) {
                throw error;
              }
            }
        
            // get the branch changelog content
            const { data: fileContents } = await github.rest.repos.getContent({
              owner,
              repo,
              ref: branchRef,
              path: filePath
            });
        
            const content = Buffer.from(fileContents.content, 'base64').toString('utf-8');
        
            // if the content doesn't include the version and date, add it
            if (!content.includes(`[${version}] - ${date}`)) {
              const lines = content.split('\n');
        
              // Add the new version and date to the changelog
              for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
                // Add the new version and date to the changelog below the unreleased title
                if (lines[lineNumber].startsWith(unreleasedTitle)) {
                  lines.splice(lineNumber + 1, 0, releaseTitle);
                  // Add a new line below the new version
                  lines.splice(lineNumber + 1, 0, "")
                } else if (lines[lineNumber].startsWith(unreleasedUrlPrefix)) {
                  const lineContent = lines[lineNumber];
                  // Update the unreleased compare line to point to the new version
                  lines[lineNumber] = lineContent.replace(/unreleased/g, version).replace(/HEAD/g, version)
                  // Add a new unreleased compare line above the new version
                  lines.splice(lineNumber, 0, `[unreleased]: https://github.com/${owner}/${repo}/compare/${version}...HEAD`)
                }
              }
              // Join the lines back together
              const newContent = lines.join('\n');
        
              // push the new changelog content to the branch
              await github.rest.repos.createOrUpdateFileContents({
                owner,
                repo,
                path: filePath,
                message: `update changelog for ${version} release`,
                content: Buffer.from(newContent).toString('base64'),
                branch: branchTitle,
                sha: fileContents.sha
              })
            }
        
            // Try to create a new PR
            try {
              await github.rest.pulls.create({
                owner,
                repo,
                issue: issue.number,
                head: branchTitle,
                base: 'main',
              })
            } catch (error) {
              // ignore error if the PR already exists
              if (error.status !== 422) {
                throw error;
              }
            }
            
              


            
